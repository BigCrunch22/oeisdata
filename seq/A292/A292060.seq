%I A292060 #29 Jul 15 2020 04:33:43
%S A292060 0,0,0,2,4,8,12,17,23,30,37
%N A292060 Minimum number of points of the square lattice falling strictly inside an equilateral triangle of side n.
%C A292060 Due to the symmetry and periodicity of the square lattice it is sufficient to explore possible equilateral triangles with center belonging to the triangular region with vertices (0,0), (1/2, 0), and (1/2, 1/2), and for every center the orientations between 0 and 2*Pi/3 radians must be explored. A simple strategy to obtain this sequence is to explore many triangles with centers and orientations in the previously described regions and count the points falling strictly inside the triangles, then picking the minimum number obtained. In the given Mathematica program the explored triangles are generated by regularly moving its center with constant increment in both main orthogonal directions, and for every center different orientations are generated with constant angular step increment.
%C A292060 Is there any criterion to determine how small should be the pitch and the angular increment in order to catch an equilateral triangle with the smallest possible number of points for a given side length n?
%C A292060 The different regions for the centers producing constant minimum numbers of lattice points inside equilateral triangles of side length n seem to become very complex and irregular as n increases (see density plots in Links).
%H A292060 Andres Cicuttin, <a href="/A292060/a292060.pdf">Plots of regions for centers of equilateral triangles of several side lengths n enclosing constant minimum number of lattice points</a>
%F A292060 a(n) ~ (1/4)*sqrt(3)*n^2.
%t A292060 (* This gives a polar function of a "k" sides polygon with side length "sidelength" and vertical rightmost side  *)
%t A292060 PolarPolygonSide[sidelength_, theta_, k_] := ((sidelength/2)/Tan[Pi/k])/Cos[Mod[theta - Pi/k , 2 Pi/k] - Pi/k];
%t A292060 (* uncomment next to generate and plot different polygons *)
%t A292060 (* Manipulate[PolarPlot[PolarPolygonSide[sidelength, theta + phase, sides], {theta, 0, 2 Pi}, PlotRange -> sidelength, GridLines -> {Range[-sidelength, sidelength] + di, Range[-sidelength, sidelength] + dj}], {sidelength, 1, 10, 1}, {sides, 3, 30, 1}, {phase, 0, 2 Pi/3, 2 Pi/300}, {dj, 0, 1/2, 0.01}, {di, 0, 1/2, 0.01}] *)
%t A292060 (* This function gives 1 if the point of coordinates (x,y) is strictly inside a polygon given by PolarPolygonSide[sidelength, theta, sides] rotated by "phase", and 0 otherwise *)
%t A292060 TruePointInsidePhase[x_, y_, sidelength_, phase_, sides_] :=
%t A292060   Module[{theta},
%t A292060    theta = ArcTan[x, y] + phase;
%t A292060    If[x^2 + y^2 == 0, 1,
%t A292060      If[x^2 + y^2 - (PolarPolygonSide[sidelength, theta, sides]^2) <
%t A292060        0, 1, 0]] // Return];
%t A292060 sides = 3; (* number of sides of the polygon *)
%t A292060 (* The following step increments seem to be small enough for sidelengths up to 10 *)
%t A292060 dstep = 0.01; (* scanning step on x and y *)
%t A292060 phasestep = 2 Pi/3000; (* orientation angular increment step *)
%t A292060 seq = {};
%t A292060 Do[
%t A292060 npoints = {}; k = 0;
%t A292060 Do[Do[Do[
%t A292060      Do[Do[
%t A292060        k =
%t A292060         k + TruePointInsidePhase[i + di, j + dj, sidelength, phase,
%t A292060           sides]
%t A292060        , {i, -sidelength - 1, sidelength + 1, 1}], {j, -sidelength -
%t A292060         1, sidelength + 1, 1}];
%t A292060      AppendTo[npoints, k];
%t A292060      k = 0;
%t A292060      , {dj, 0, 1/2, dstep}], {di, 0, 1/2, dstep}], {phase, 0, 2 Pi/3,
%t A292060     phasestep}] // Quiet;
%t A292060 temp = npoints // Min;
%t A292060 AppendTo[seq, temp];
%t A292060 , {sidelength, 0, 10, 1}]
%t A292060 seq
%Y A292060 Cf. A291259, A292896.
%K A292060 nonn,hard,more
%O A292060 0,4
%A A292060 _Andres Cicuttin_, Sep 08 2017
