%I A354076 #61 Jun 14 2022 01:41:00
%S A354076 1,1,2,4,10,23,60,153,405,1076,2909,7907,21693,59834,166004,462612,
%T A354076 1294612,3635809,10244017
%N A354076 Number of (unordered) plane trees with n leaves, such that for every node the number of "children of children" has no common divisor > 1.
%C A354076 This sequence can be generated by the following algorithm: Starting with the array [1], one can use the following replacement rule: Let k be an arbitrary natural number. For any element x of the array, we replace x with k copies of k*x. The leaves then represent the numbers in the array, with the structure being governed by the prime factorization of the entries. The leaf "height" is then described by the number of prime factors in the factorization of that number. a(n) is the number of distinct arrays (up to permutations) of a fixed length n that can be generated this way.
%C A354076 Another way of describing this problem is sketched in the Math.SE post in the links: Given n arithmetic progressions with terms a_i, how many ways (up to identical terms a_i) are there to disjointly cover the residue classes modulo the lcm of all a_i?
%C A354076 This sequence arose in the "inverse covering set" problem. Normally when considering covering sets (see the corresponding Wikipedia article below), we fix a base b and want to find a set of primes P and factor k such that k*b^m+1 is divisible by a prime in P for any natural number m (so it is a sequence that is non-obviously always composite). The "inverse" problem is: Given P and a set of multiplicative orders of b^(...) modulo the primes in P, can we find a b fitting these criteria? The number of "allowed" sets (i.e., non-overlapping covered residues) of multiplicative orders for n primes is then represented by a(n). They are a special case of representing 1 as a sum of Egyptian fractions where one can always group appropriate terms and gain a smaller set with the same property.
%C A354076 a(n-1) <= a(n) <= A000699(n).
%H A354076 MathStackExchange, <a href="https://math.stackexchange.com/questions/4469815/egyptian-unit-decomposition-coverings-of-mathbbz-p-by-arithmetic-progress">Egyptian unit decomposition + coverings of Zp by arithmetic progressions</a>.
%H A354076 Wikipedia, <a href="https://en.wikipedia.org/wiki/Covering_set">Covering set</a>
%e A354076 The number of possible "splittings" can be found by the algorithmic approach outlined above.
%e A354076 For n = 3:
%e A354076   [1] -> [2,2] -> [2,4,4]
%e A354076   [1] -> [3,3,3]
%e A354076   so a(3) = 2.
%e A354076 For n = 4:
%e A354076   [1] -> [2,2] -> [2,4,4] -> [2,4,8,8] or [4,4,4,4]
%e A354076   [1] -> [2,2] -> [2,6,6,6]
%e A354076   [1] -> [3,3,3] -> [3,3,6,6]
%e A354076   so a(4) = 4.
%o A354076 (Julia)
%o A354076 function validCoverings(n)
%o A354076     coverings = [[1]]
%o A354076     for m in 2:n
%o A354076         len = length(coverings)
%o A354076         for i in 1:len
%o A354076             replacelen = m-length(coverings[i])+1
%o A354076             for j in 1:length(coverings[i])
%o A354076                 val = coverings[i][j]
%o A354076                 newCover = copy(coverings[i])
%o A354076                 deleteat!(newCover, j)
%o A354076                 for k in 1:replacelen
%o A354076                     insert!(newCover, j, val*replacelen)
%o A354076                 end
%o A354076                 newCover = sort(newCover)
%o A354076                 if(!(newCover in coverings))
%o A354076                     append!(coverings, [newCover])
%o A354076                 end
%o A354076             end
%o A354076         end
%o A354076     end
%o A354076     length(filter((x) -> length(x)==n, coverings))
%o A354076 end
%Y A354076 Cf. A000699.
%K A354076 nonn,more
%O A354076 1,3
%A A354076 _Toni Wunderlich_, Jun 12 2022
%E A354076 a(15)-a(19) added by Richard Knäbchen (Mathematics undergraduate at the "Technische Universität Chemnitz")
