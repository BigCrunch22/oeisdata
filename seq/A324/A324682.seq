%I A324682 #14 Jan 10 2023 10:55:04
%S A324682 0,0,-1,0,-1,1,0,-1,-1,1,0,-1,-1,1,-1,0,1,0,-1,1,1,0,-1,-1,1,0,-1,1,0,
%T A324682 -1,-1,-1,-1,1,1,-1,0,-1,-1,-1,-1,-1,-1,1,1,0,-1,-1,1,-1,1,1,-1,-1,1,
%U A324682 0,-1,-1,-1,-1,-1,1,1,1,-1,-1,0,-1,1,0,-1,-1,-1
%N A324682 Starting at n, a(n) is the sign of the closest nonzero point to zero visited for which the next move is a step away from zero, according to the following rules. On the k-th step (k=1,2,3,...) move a distance of k in the direction of zero. If the number landed on has been landed on before, move a distance of k away. In the case of a tie, or if the set of points is empty, we set a(n)=0.
%e A324682 For n=9, the points visited are 9, 8, 6, 3, -1, 4, -2, 5, -3, -12, -22, -11, 1, 14, 0. The three times moves are made away from zero happen at -3, -12 and 1. The closest of these is to zero is 1 and thus a(9) = sgn(1) = 1.
%o A324682 (Python)
%o A324682 #Sequences A324660-A324692 generated by manipulating this trip function
%o A324682 #spots - positions in order with possible repetition
%o A324682 #flee - positions from which we move away from zero with possible repetition
%o A324682 #stuck - positions from which we move to a spot already visited with possible repetition
%o A324682 def trip(n):
%o A324682     stucklist = list()
%o A324682     spotsvisited = [n]
%o A324682     leavingspots = list()
%o A324682     turn = 0
%o A324682     forbidden = {n}
%o A324682     while n != 0:
%o A324682         turn += 1
%o A324682         sign = n // abs(n)
%o A324682         st = sign * turn
%o A324682         if n - st not in forbidden:
%o A324682             n = n - st
%o A324682         else:
%o A324682             leavingspots.append(n)
%o A324682             if n + st in forbidden:
%o A324682                 stucklist.append(n)
%o A324682             n = n + st
%o A324682         spotsvisited.append(n)
%o A324682         forbidden.add(n)
%o A324682     return {'stuck':stucklist, 'spots':spotsvisited,
%o A324682                 'turns':turn, 'flee':leavingspots}
%o A324682 def sgn(x):
%o A324682     if x:
%o A324682         return x//abs(x)
%o A324682     return 0
%o A324682 def maxorzero(x):
%o A324682     if x:
%o A324682         return max(x)
%o A324682     return 0
%o A324682 def minorzero(x):
%o A324682     if x:
%o A324682         return min(x)
%o A324682     return 0
%o A324682 #Actual sequence
%o A324682 def a(n):
%o A324682     d = trip(n)
%o A324682     neg=maxorzero([i for i in d['flee'] if i < 0])
%o A324682     pos=minorzero([i for i in d['flee'] if i > 0])
%o A324682     if neg and not pos:
%o A324682         return -1
%o A324682     return -sgn(neg+pos)
%Y A324682 Cf. A228474, A324660-A324692.
%K A324682 sign
%O A324682 0,1
%A A324682 _David Nacin_, Mar 10 2019
