%I A344499 #27 Jun 06 2024 13:08:24
%S A344499 1,0,1,0,1,1,0,3,2,1,0,13,10,3,1,0,75,74,21,4,1,0,541,730,219,36,5,1,
%T A344499 0,4683,9002,3045,484,55,6,1,0,47293,133210,52923,8676,905,78,7,1,0,
%U A344499 545835,2299754,1103781,194404,19855,1518,105,8,1,0,7087261,45375130,26857659,5227236,544505,39390,2359,136,9,1
%N A344499 T(n, k) = F(n - k, k), where F(n, x) is the Fubini polynomial. Triangle read by rows, T(n, k) for 0 <= k <= n.
%C A344499 The array rows are recursively generated by applying the Akiyama-Tanigawa algorithm to the powers (see the Python implementation below). In this way the array becomes the image of A004248 under the AT-transformation when applied to the columns of A004248. This makes the array closely linked to A371761, which is generated in the same way, but applied to the rows of A004248. - _Peter Luschny_, Apr 27 2024
%F A344499 T(n, k) = (n - k)! * [x^(n - k)] (1 / (1 + k * (1 - exp(x)))).
%F A344499 T(2*n, n) = A094420(n).
%e A344499 Triangle starts:
%e A344499 [0] 1;
%e A344499 [1] 0, 1;
%e A344499 [2] 0, 1,      1;
%e A344499 [3] 0, 3,      2,       1;
%e A344499 [4] 0, 13,     10,      3,       1;
%e A344499 [5] 0, 75,     74,      21,      4,      1;
%e A344499 [6] 0, 541,    730,     219,     36,     5,     1;
%e A344499 [7] 0, 4683,   9002,    3045,    484,    55,    6,    1;
%e A344499 [8] 0, 47293,  133210,  52923,   8676,   905,   78,   7,   1;
%e A344499 [9] 0, 545835, 2299754, 1103781, 194404, 19855, 1518, 105, 8, 1;
%e A344499 .
%e A344499 Seen as an array A(n, k) = T(n + k, n):
%e A344499 [0] [1, 0,   0,    0,     0,       0,         0, ...  A000007
%e A344499 [1] [1, 1,   3,   13,    75,     541,      4683, ...  A000670
%e A344499 [2] [1, 2,  10,   74,   730,    9002,    133210, ...  A004123
%e A344499 [3] [1, 3,  21,  219,  3045,   52923,   1103781, ...  A032033
%e A344499 [4] [1, 4,  36,  484,  8676,  194404,   5227236, ...  A094417
%e A344499 [5] [1, 5,  55,  905, 19855,  544505,  17919055, ...  A094418
%e A344499 [6] [1, 6,  78, 1518, 39390, 1277646,  49729758, ...  A094419
%e A344499 [7] [1, 7, 105, 2359, 70665, 2646007, 118893705, ...  A238464
%p A344499 F := proc(n) option remember; if n = 0 then return 1 fi:
%p A344499 expand(add(binomial(n, k)*F(n - k)*x, k = 1..n)) end:
%p A344499 seq(seq(subs(x = k, F(n - k)), k = 0..n), n = 0..10);
%t A344499 F[n_] := F[n] = If[n == 0, 1,
%t A344499    Expand[Sum[Binomial[n, k]*F[n - k]*x, {k, 1, n}]]];
%t A344499 Table[Table[F[n - k] /. x -> k, {k, 0, n}], {n, 0, 10}] // Flatten (* _Jean-Fran√ßois Alcover_, Jun 06 2024, after _Peter Luschny_ *)
%o A344499 (SageMath)  # Computes the triangle.
%o A344499 @cached_function
%o A344499 def F(n):
%o A344499     R.<x> = PolynomialRing(ZZ)
%o A344499     if n == 0: return R(1)
%o A344499     return R(sum(binomial(n, k)*F(n - k)*x for k in (1..n)))
%o A344499 def Fval(n): return [F(n - k).substitute(x = k) for k in (0..n)]
%o A344499 for n in range(10): print(Fval(n))
%o A344499 (SageMath)  # Computes the square array using the Akiyama-Tanigawa algorithm.
%o A344499 def ATFubini(n, len):
%o A344499     A = [0] * len
%o A344499     R = [0] * len
%o A344499     for k in range(len):
%o A344499         R[k] = (n + 1)**k  # Chancing this to R[k] = k**n generates A371761.
%o A344499         for j in range(k, 0, -1):
%o A344499             R[j - 1] = j * (R[j] - R[j - 1])
%o A344499         A[k] = R[0]
%o A344499     return A
%o A344499 for n in range(8): print([n], ATFubini(n, 7))  # _Peter Luschny_, Apr 27 2024
%Y A344499 Variant of the array is A094416 (which has column 0 and row 0 missing).
%Y A344499 The coefficients of the Fubini polynomials are A131689.
%Y A344499 Cf. A094420 (main diagonal of array), A372346 (row sums), A004248, A371761.
%K A344499 nonn,tabl,changed
%O A344499 0,8
%A A344499 _Peter Luschny_, May 21 2021
