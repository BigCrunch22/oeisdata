%I A108736 #8 Aug 08 2015 21:56:44
%S A108736 0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,0,1,0,1,0,1,1,0,1,1,1,1,0,0,0,0,0,
%T A108736 1,1,0,0,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,
%U A108736 0,0,0,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,0
%N A108736 Start with S = {}. For m = 1, 2, 3, ... in turn, examine all 2^m m-bit strings u in arithmetic order. If u is not a substring of S, append the minimal number of 0's and 1's to S to remedy this. Sequence gives S.
%e A108736 We construct S as follows, starting with S = {}.
%e A108736 0 is missing, so S = {0};
%e A108736 1 is missing, so S = {0,1};
%e A108736 00 is missing, so S = {0,1,0,0};
%e A108736 01 and 10 are now visible, but 11 is missing, so S = {0,1,0,0,1,1};
%e A108736 000 is missing, so S = {0,1,0,0,1,1,0,0,0}; etc.
%p A108736 bString := proc(n,m) local a,i; a := [] ; for i from m-1 to 0 by -1 do a := [op(a), floor(n/2^i) mod 2] ; od: RETURN(a) ; end: A108736 := proc(nmax) local S,m,b,partoverl,overl,mbstr; S := [] ; m := 1: while nops(S) < nmax do for b from 0 to 2^m-1 do mbstr := bString(b,m) ; if verify(mbstr,S,'sublist') = false then partoverl := false ; for overl from m-1 to 1 by -1 do if verify(mbstr[1..overl],S[ -overl..-1],'sublist') = true then S := [op(S),op(mbstr[overl+1..nops(mbstr)])] ; partoverl := true ; break ; fi ; od; if partoverl = false then S := [op(S),op(mbstr)] ; fi ; fi ; od: m := m+1: od: RETURN(S) ; end: op(A108736(80)) ; # _R. J. Mathar_, Aug 15 2007
%Y A108736 Cf. A108737.
%K A108736 nonn,easy
%O A108736 1,1
%A A108736 _N. J. A. Sloane_, Jun 23 2005
%E A108736 More terms from _R. J. Mathar_, Aug 15 2007
